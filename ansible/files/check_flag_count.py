#!/usr/bin/env python3
"""
Flag Counter - Counts total planted flags for Blue Team visibility.

==============================================================================
WHAT IS THIS?
==============================================================================
This script counts how many valid Red Team flags are currently planted across
all monitored systems. It's designed to give Blue Team visibility into the
threat level WITHOUT revealing specific flag locations.

BLUE TEAM EXPERIENCE:
- Scoreboard shows: "DETECTED_3" (3 flags planted somewhere)
- Blue Team knows they need to hunt for flags
- They don't know WHICH boxes have flags - that's for them to investigate!

WHY NOT SHOW LOCATIONS?
If we told Blue Team "flag on webserver at /var/www/html/flag.txt", they'd
just delete it immediately. By only showing a count, Blue Team must:
1. Actively search their systems for suspicious files
2. Learn to detect intrusion indicators
3. Develop incident response skills

This mirrors real-world scenarios where defenders know they're compromised
but must investigate to find the actual malware/backdoors.

==============================================================================
PYTHON CONCEPTS USED
==============================================================================

1. JSON MODULE
   JSON (JavaScript Object Notation) is a text format for structured data.
   Python's json module converts between JSON strings and Python objects.
   json.load() reads a file into a dict/list, json.dumps() writes it back.

2. DICTIONARY METHODS
   config.get('paths', {}) safely gets a key with a default if missing.
   paths.items() iterates over key-value pairs in a dictionary.

3. FOR LOOPS WITH MULTIPLE VARIABLES
   "for box_name, search_path in paths.items()" unpacks each (key, value)
   pair into separate variables. Called "tuple unpacking".

4. BREAK STATEMENT
   "break" exits the innermost loop immediately. We use it to stop searching
   a directory once we find a valid flag (one flag per box is enough).

==============================================================================
OUTPUT
==============================================================================
    CLEAR       - No flags detected (good for Blue Team!)
    DETECTED_N  - N flags found somewhere (Blue Team needs to investigate)
"""

# ==============================================================================
# IMPORTS
# ==============================================================================

import json  # JSON parsing - reads configuration from flag-paths.json
import os    # Operating system interface - file operations, directory walking
import sys   # System-specific parameters (unused but commonly needed)

# ==============================================================================
# CONFIGURATION
# ==============================================================================
# These paths must match where the Ansible playbook deploys the files

# JSON file listing all flag search paths (generated by Ansible template)
# Format: {"filename": "flag.txt", "paths": {"webserver": "/var/www/html", ...}}
CONFIG_FILE = '/opt/scoring-engine/flag-paths.json'

# File containing the secret token that valid flags must contain
TOKEN_FILE = '/opt/scoring-engine/red-token.txt'


# ==============================================================================
# FLAG COUNTING
# ==============================================================================

def count_flags() -> int:
    """
    Count valid flags across all configured search paths.

    ALGORITHM:
    1. Load the Red Team token (what flags must contain)
    2. Load the configuration (which paths to search)
    3. For each box's flag path:
       a. Walk the directory tree
       b. Look for files named flag.txt (or configured filename)
       c. If found, check if contents match the token
       d. Count one flag per box maximum (prevents counting duplicates)
    4. Return total count

    WHY ONE FLAG PER BOX?
    Red Team might plant multiple flag files on one system. We only count
    one per box to keep scoring fair - otherwise they could inflate their
    score by creating 100 flags in 100 subdirectories on one system.

    Returns:
        Number of boxes with valid flags planted
    """

    # -------------------------------------------------------------------------
    # STEP 1: Load the Red Team token
    # -------------------------------------------------------------------------
    try:
        with open(TOKEN_FILE, 'r') as f:
            token = f.read().strip()
    except FileNotFoundError:
        # No token file = no flags can be valid
        # This could happen if flag system isn't fully configured yet
        return 0

    # -------------------------------------------------------------------------
    # STEP 2: Load the flag paths configuration
    # -------------------------------------------------------------------------
    # This JSON file is generated by Ansible from the scoring_boxes variable
    try:
        with open(CONFIG_FILE, 'r') as f:
            # json.load() parses JSON file into Python dict
            config = json.load(f)
    except FileNotFoundError:
        # Config file doesn't exist yet
        return 0
    except json.JSONDecodeError:
        # Config file exists but isn't valid JSON
        # This would be a configuration error
        return 0

    # -------------------------------------------------------------------------
    # STEP 3: Extract configuration values
    # -------------------------------------------------------------------------
    # .get() is a safe dictionary access that returns a default if key missing
    # config.get('paths', {}) returns the 'paths' value, or {} if not found
    paths = config.get('paths', {})
    filename = config.get('filename', 'flag.txt')

    # -------------------------------------------------------------------------
    # STEP 4: Count flags across all boxes
    # -------------------------------------------------------------------------
    count = 0

    # .items() returns (key, value) pairs from the dictionary
    # This iterates through each box and its search path
    for box_name, search_path in paths.items():
        # Track if we found a flag on this specific box
        # (We only want to count one flag per box)
        found_on_this_box = False

        try:
            # os.walk() recursively traverses directory tree
            # yields (current_dir, subdirectories, files) for each directory
            for root, dirs, files in os.walk(search_path):

                # Check if the flag file exists in this directory
                if filename in files:
                    # Build full path to the potential flag
                    flag_path = os.path.join(root, filename)

                    try:
                        # Try to read and validate the flag
                        with open(flag_path, 'r') as f:
                            file_content = f.read().strip()

                            # Check if this file contains the correct token
                            if file_content == token:
                                count += 1
                                found_on_this_box = True

                                # BREAK: Stop searching this box's directory tree
                                # We found a valid flag, no need to keep looking
                                # on this particular box
                                break

                    except (IOError, PermissionError):
                        # Can't read this file - permission denied or I/O error
                        # Continue searching, might find another flag file
                        continue

            # If we found a flag and broke out of the inner loop,
            # we continue to the next box (the outer for loop)

        except (IOError, PermissionError):
            # Can't access this box's search path at all
            # Skip to the next box
            continue

    return count


# ==============================================================================
# MAIN FUNCTION
# ==============================================================================

def main():
    """
    Main entry point - count flags and print result.

    OUTPUT FORMAT:
    The scoring engine runs this script and checks the output.
    - "CLEAR" means no flags detected - Blue Team is doing well
    - "DETECTED_N" means N flags found - Blue Team needs to investigate

    The scoring engine can be configured to:
    - Award points to Red Team for each flag detected
    - Show the count on Blue Team's scoreboard
    - Trigger alerts when new flags appear
    """
    # Count all valid flags across all configured paths
    count = count_flags()

    # Print result for scoring engine to capture
    if count == 0:
        print("CLEAR")
    else:
        # f-string (formatted string literal) embeds variables in strings
        # f"DETECTED_{count}" with count=3 produces "DETECTED_3"
        print(f"DETECTED_{count}")


# ==============================================================================
# SCRIPT ENTRY POINT
# ==============================================================================
# Standard Python idiom: only run main() when script is executed directly.
# __name__ equals '__main__' when running directly, or module name when imported.

if __name__ == '__main__':
    main()
