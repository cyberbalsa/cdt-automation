---
# ==============================================================================
# SCORING ENGINE ROLE - TASKS
# ==============================================================================
# This file contains all the steps Ansible performs to install and configure
# the DWAYNE-INATOR-5000 scoring engine.
#
# WHAT ARE ANSIBLE TASKS?
# Tasks are individual actions Ansible performs on target servers. They run
# in order from top to bottom. Each task uses a "module" (like apt, copy, file)
# to perform a specific action.
#
# TASK STRUCTURE:
#   - name: Human-readable description (shows in output)
#     ansible.builtin.module_name:    # Which module to use
#       parameter1: value1            # Module-specific options
#       parameter2: value2
#     register: result_variable       # Save output to a variable (optional)
#     when: condition                 # Only run if condition is true (optional)
#     notify: handler_name            # Trigger a handler when task changes something
#
# WHAT THIS ROLE DOES (in order):
# 1. Installs Go programming language and build tools (gcc, git)
# 2. Creates a directory for the scoring engine
# 3. Copies the scoring engine source code from this repo to the server
# 4. Compiles (builds) the Go code into an executable program
# 5. Generates the configuration file from your settings
# 6. Sets up a systemd service so it runs automatically
# 7. Starts the service and verifies it's working
#
# DOCUMENTATION:
# - Ansible Tasks: https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_intro.html
# - Module Index: https://docs.ansible.com/ansible/latest/collections/index_module.html
# ==============================================================================

# ------------------------------------------------------------------------------
# STEP 1: Install Build Dependencies
# ------------------------------------------------------------------------------
# The scoring engine is written in Go, so we need the Go compiler.
# It also uses go-sqlite3 which requires gcc (a C compiler) to build.

- name: Install build dependencies
  ansible.builtin.apt:
    # APT MODULE: Installs packages on Debian/Ubuntu systems
    # Similar to running: sudo apt install golang-go gcc git
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html
    name:
      - golang-go    # Go programming language compiler
      - gcc          # C compiler (required for go-sqlite3)
      - git          # Version control (used during Go builds)
    state: present       # Ensure packages are installed (vs. absent to remove)
    update_cache: true   # Run 'apt update' first to refresh package lists
  register: deps_install
  # REGISTER: Saves the task's output to a variable (deps_install)
  # We can check deps_install.changed to see if anything was installed

- name: Display Go version
  ansible.builtin.command: go version
  # COMMAND MODULE: Runs shell commands
  # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/command_module.html
  register: go_version
  changed_when: false
  # CHANGED_WHEN: Tells Ansible when to consider this task as having "changed" something
  # 'false' means this task never reports a change (it's just checking, not modifying)

- name: Show Go version
  ansible.builtin.debug:
    # DEBUG MODULE: Prints messages during playbook execution
    # Useful for showing variable values or status information
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html
    msg: "{{ go_version.stdout }}"
    # {{ variable }} is Jinja2 syntax - Ansible replaces it with the variable's value

# ------------------------------------------------------------------------------
# STEP 2: Create Installation Directory
# ------------------------------------------------------------------------------
# Create a dedicated directory for the scoring engine files

- name: Create scoring engine directory
  ansible.builtin.file:
    # FILE MODULE: Manages files and directories
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/file_module.html
    path: "{{ scoring_install_dir }}"    # Directory path (default: /opt/scoring-engine)
    state: directory                      # Create a directory (vs. file, link, absent)
    owner: "{{ scoring_service_user }}"   # Who owns the directory
    mode: "0755"                          # Permissions: rwxr-xr-x (owner can write, others can read/execute)

# ------------------------------------------------------------------------------
# STEP 3: Copy Scoring Engine Source
# ------------------------------------------------------------------------------
# Copy the scoring engine code from this repository to the target server
# The source is in the git submodule at scoring/DWAYNE-INATOR-5000/

- name: Copy DWAYNE-INATOR-5000 source
  ansible.builtin.copy:
    # COPY MODULE: Copies files from the control machine to target servers
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/copy_module.html
    src: "{{ playbook_dir }}/../../scoring/DWAYNE-INATOR-5000/"
    # playbook_dir is a magic variable = directory containing the playbook
    # So this resolves to: ansible/playbooks/../../scoring/DWAYNE-INATOR-5000/
    # Which simplifies to: scoring/DWAYNE-INATOR-5000/ (at repo root)
    dest: "{{ scoring_install_dir }}/"
    owner: "{{ scoring_service_user }}"
    mode: preserve    # Keep original file permissions
  register: source_copy
  # We register this so we can check if files changed and trigger a rebuild

# ------------------------------------------------------------------------------
# STEP 4: Build Scoring Engine
# ------------------------------------------------------------------------------
# Compile the Go source code into an executable binary
# This is like running: cd /opt/scoring-engine && go build -o dwayne-inator

- name: Build scoring engine binary
  ansible.builtin.command:
    cmd: go build {{ scoring_go_build_flags }} -o {{ scoring_binary_name }}
    chdir: "{{ scoring_install_dir }}"    # Change to this directory before running
    creates: "{{ scoring_install_dir }}/{{ scoring_binary_name }}"
    # CREATES: Only run this task if the specified file DOESN'T exist
    # This makes the task idempotent (safe to run multiple times)
    # First run: binary doesn't exist -> task runs
    # Second run: binary exists -> task skips (saves time!)
  environment:
    # ENVIRONMENT: Set environment variables for this command
    # Go uses these to cache downloaded packages and compiled code
    GOCACHE: "{{ scoring_install_dir }}/.cache/go-build"
    GOPATH: "{{ scoring_install_dir }}/.cache/go"
  register: build_result

- name: Rebuild if source changed
  ansible.builtin.command:
    cmd: go build {{ scoring_go_build_flags }} -o {{ scoring_binary_name }}
    chdir: "{{ scoring_install_dir }}"
  environment:
    GOCACHE: "{{ scoring_install_dir }}/.cache/go-build"
    GOPATH: "{{ scoring_install_dir }}/.cache/go"
  when: source_copy.changed
  # WHEN: Conditional execution - only run this task if condition is true
  # source_copy.changed is true if the copy task actually changed files
  # This ensures we rebuild when the code updates
  notify: Restart scoring engine
  # NOTIFY: Trigger the "restart scoring engine" handler
  # Handler won't run immediately - it runs after all tasks complete
  changed_when: true

# ------------------------------------------------------------------------------
# STEP 5: Deploy Configuration
# ------------------------------------------------------------------------------
# Generate the dwayne.conf configuration file from our YAML variables
# The template transforms group_vars/scoring.yml into TOML format

- name: Deploy scoring engine configuration
  ansible.builtin.template:
    # TEMPLATE MODULE: Process Jinja2 templates and copy to target
    # Unlike 'copy', this evaluates {{ variables }} and {% logic %}
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html
    src: dwayne.conf.j2          # Template file (in role's templates/ directory)
    dest: "{{ scoring_install_dir }}/dwayne.conf"
    owner: "{{ scoring_service_user }}"
    mode: "0640"    # rw-r----- (owner read/write, group read, others nothing)
                    # More restrictive because config may contain passwords
  notify: Restart scoring engine

# ------------------------------------------------------------------------------
# STEP 6: Deploy Systemd Service
# ------------------------------------------------------------------------------
# Create a systemd service so the scoring engine:
# - Starts automatically when the server boots
# - Restarts automatically if it crashes
# - Can be controlled with systemctl commands

- name: Deploy systemd service unit
  ansible.builtin.template:
    src: dwayne.service.j2
    dest: /etc/systemd/system/{{ scoring_service_name }}.service
    # /etc/systemd/system/ is where custom services go
    owner: root
    mode: "0644"
  notify:
    # You can notify multiple handlers!
    - Reload systemd       # Tell systemd to re-read service files
    - Restart scoring engine

# ------------------------------------------------------------------------------
# STEP 7: Enable and Start Service
# ------------------------------------------------------------------------------
# Enable = start on boot, Started = start right now

- name: Enable and start scoring engine service
  ansible.builtin.systemd:
    # SYSTEMD MODULE: Manage systemd services
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/systemd_module.html
    name: "{{ scoring_service_name }}"
    enabled: true      # Start on boot (like: systemctl enable dwayne-inator)
    state: started     # Start now (like: systemctl start dwayne-inator)
    daemon_reload: true  # Reload systemd config first (in case service file changed)

# ------------------------------------------------------------------------------
# STEP 8: Verify Service is Running
# ------------------------------------------------------------------------------
# Make sure the scoring engine actually started and is accepting connections

- name: Wait for scoring engine to start
  ansible.builtin.wait_for:
    # WAIT_FOR MODULE: Wait for a condition before continuing
    # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/wait_for_module.html
    port: "{{ scoring_port }}"   # Wait for this port to be open
    host: 127.0.0.1              # Check localhost (we're on the scoring server)
    delay: 5                     # Wait 5 seconds before first check
    timeout: 60                  # Fail if not ready within 60 seconds

- name: Display service status
  ansible.builtin.command: systemctl status {{ scoring_service_name }}
  register: service_status
  changed_when: false

- name: Show service status
  ansible.builtin.debug:
    msg: "{{ service_status.stdout_lines }}"
    # stdout_lines splits the output into a list (one item per line)
    # This makes it display nicely in Ansible's output

# ==============================================================================
# FLAG SYSTEM DEPLOYMENT (Optional Attack/Defend Mechanics)
# ==============================================================================
# These tasks deploy the attack/defend flag system components.
# Only runs when scoring_flags_enabled is true in your configuration.
#
# WHAT IS THE FLAG SYSTEM?
# In attack/defend CTF competitions, Red Team can earn points by planting
# "flag" files on compromised systems. The flag system:
# 1. Generates a secret token for Red Team
# 2. Deploys scripts to check for valid flags
# 3. Runs a token server so Red Team can retrieve their token
# 4. Only awards points when the associated service is UP
#
# WHY REQUIRE SERVICE UP?
# This prevents "scorched earth" tactics where Red Team just destroys
# everything. They must maintain stealthy persistent access to score!
#
# CONDITIONAL EXECUTION:
# Notice that every task below has "when: scoring_flags_enabled | default(false)"
# This means these tasks ONLY run if you set scoring_flags_enabled: true
# in your group_vars/scoring.yml file. The | default(false) ensures we
# don't get an error if the variable isn't defined at all.
# ==============================================================================

# ------------------------------------------------------------------------------
# FLAG STEP 1: Generate Red Team Token
# ------------------------------------------------------------------------------
# Create a random 32-character hex token that Red Team uses in their flags.
# This is generated once and stored in a file. Using 'creates' ensures we
# don't regenerate it on subsequent runs (which would invalidate existing flags).

- name: Generate Red team token
  ansible.builtin.shell: |
    openssl rand -hex 16 > {{ scoring_install_dir }}/red-token.txt
    chmod 600 {{ scoring_install_dir }}/red-token.txt
  # SHELL MODULE: Like command, but allows pipes, redirects, and shell features
  # Docs: https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html
  #
  # WHAT THIS DOES:
  # - openssl rand -hex 16: Generate 16 random bytes, output as 32 hex characters
  # - > red-token.txt: Write output to file (redirect)
  # - chmod 600: Set permissions to rw------- (only owner can read/write)
  args:
    creates: "{{ scoring_install_dir }}/red-token.txt"
    # CREATES: Only run if this file DOESN'T exist
    # Prevents regenerating the token (which would break existing flags)
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 2: Create State Directory
# ------------------------------------------------------------------------------
# The flag checker needs a directory to store round counters for rate limiting.
# Each service gets a file like "webserver_web.count" that tracks which round we're on.

- name: Create flag state directory
  ansible.builtin.file:
    path: "{{ scoring_install_dir }}/flag-state"
    state: directory
    owner: "{{ scoring_service_user }}"
    mode: "0755"
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 3: Create Checkfiles Directory
# ------------------------------------------------------------------------------
# Ensure the checkfiles directory exists for our flag checking scripts.
# The scoring engine looks here for custom check scripts.

- name: Create checkfiles directory
  ansible.builtin.file:
    path: "{{ scoring_install_dir }}/checkfiles"
    state: directory
    owner: "{{ scoring_service_user }}"
    mode: "0755"
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 4: Deploy Flag Checker Script
# ------------------------------------------------------------------------------
# This script validates individual flags:
# - Checks if the associated service is UP (queries scoring database)
# - Searches for flag files with the correct token
# - Outputs FLAG_VALID, SERVICE_DOWN, FLAG_NOT_FOUND, or SKIP_INTERVAL

- name: Deploy flag checker script
  ansible.builtin.copy:
    # COPY MODULE: src is relative to role's files/ directory
    # So "check_flag.py" looks in roles/scoring_engine/files/check_flag.py
    # But we put it in ansible/files/ so we use absolute path
    src: "{{ playbook_dir }}/../files/check_flag.py"
    dest: "{{ scoring_install_dir }}/checkfiles/check_flag.py"
    owner: "{{ scoring_service_user }}"
    mode: "0755"    # Executable
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 5: Deploy Flag Counter Script
# ------------------------------------------------------------------------------
# This script counts total flags for Blue Team visibility:
# - Searches all configured flag paths
# - Outputs CLEAR or DETECTED_N (where N is the count)
# - Blue Team sees the count but not specific locations

- name: Deploy flag counter script
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/../files/check_flag_count.py"
    dest: "{{ scoring_install_dir }}/checkfiles/check_flag_count.py"
    owner: "{{ scoring_service_user }}"
    mode: "0755"
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 6: Deploy Token Server Script
# ------------------------------------------------------------------------------
# This HTTP server lets Red Team retrieve their token programmatically:
# - Runs on a dedicated port (default: 8081)
# - Red Team uses: curl http://<scoring-server>:8081/token
# - No authentication - access controlled by network position

- name: Deploy token server script
  ansible.builtin.copy:
    src: "{{ playbook_dir }}/../files/token_server.py"
    dest: "{{ scoring_install_dir }}/token_server.py"
    owner: "{{ scoring_service_user }}"
    mode: "0755"
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 7: Deploy Flag Paths Configuration
# ------------------------------------------------------------------------------
# This JSON file tells the flag counter script where to search for flags.
# It's generated from your scoring_boxes configuration.

- name: Deploy flag paths configuration
  ansible.builtin.template:
    src: flag-paths.json.j2
    dest: "{{ scoring_install_dir }}/flag-paths.json"
    owner: "{{ scoring_service_user }}"
    mode: "0644"
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 8: Deploy Token Server Systemd Service
# ------------------------------------------------------------------------------
# Create a systemd service so the token server runs automatically.
# This is separate from the main scoring engine service.

- name: Deploy token server systemd service
  ansible.builtin.template:
    src: token-server.service.j2
    dest: /etc/systemd/system/red-token-server.service
    owner: root
    mode: "0644"
  notify:
    - Reload systemd
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 9: Enable and Start Token Server
# ------------------------------------------------------------------------------
# Start the token server and ensure it runs on boot.

- name: Enable and start token server
  ansible.builtin.systemd:
    name: red-token-server
    enabled: true
    state: started
    daemon_reload: true
  when: scoring_flags_enabled | default(false)

# ------------------------------------------------------------------------------
# FLAG STEP 10: Display Flag System Status
# ------------------------------------------------------------------------------
# Show helpful information about the flag system configuration.

- name: Display flag system status
  ansible.builtin.debug:
    msg: |
      ====================================
      FLAG SYSTEM ENABLED!
      ====================================
      Token server: http://{{ ansible_host }}:{{ scoring_red_token_port }}/token
      Flag filename: {{ scoring_flag_filename }}
      Check interval: Every {{ scoring_flag_check_interval }} rounds
      Points per flag: {{ scoring_flag_points }}

      RED TEAM INSTRUCTIONS:
      1. Get your token: curl http://{{ ansible_host }}:{{ scoring_red_token_port }}/token
      2. Plant a flag: echo "<token>" > /var/www/html/flag.txt
      3. Keep the service running to score!

      BLUE TEAM NOTES:
      - Watch the scoreboard for "DETECTED" alerts
      - Hunt for flag.txt files in your service directories
      - Delete enemy flags when you find them!
      ====================================
  when: scoring_flags_enabled | default(false)
